//! #### Graphics Subsystem
//! Graphics is the most fundamental subsystem of [Lemon3d](http://github.com/kayak233/lemon3d).
//! It was degisned to provide a set of stateless and high-performance
//! graphics APIs based on OpenGL.
//!
//! #### General Thoughts
//! First of all, we follows a data-oriented approach, and uses a task
//! scheduler to perform multithread entities resolving. Its much more
//! convenient to provide mechanism to make video resource preparations
//! and drawcall submits in different threads.
//!
//! The most common solution is by using a double-buffer of commands.
//! This consists of running the renderer backend in a speparate thread,
//! where all draw calls and communication with the OpenGL API are
//! performed. The frontend thread that runs the game logic communicates
//! with the backend renderer via a command double-buffer.
//!
//! And its important to sort video commands (generated by different
//! threads) before submiting them to OpenGL, for the sack of both
//! correctness and performance. For example, to draw transparent objects
//! via blending, we need draw opaque object first, usually from
//! front-to-back, and draw translucents from back-to-front. We can
//! achieve this point by sorting commands before swaping command-buffer.
//!
//! There are some assumptions here to keep codes as simple as possible, this
//! sometimes creates undesired results.
//! 1. All the resource creations and manipulations will be happened before
//! real draw call;
//! 2. All the resource destructions will be finished after real draw call.
//!
//! As a optimation, we use a key associated with every-drawcall to sort.
//! Typically, a key is just a single 32-bit or 64-bit integer encoded
//! certain data like distance, material, shader, etc. of a draw call in
//! individual bits. Depending on where those bits are stored in the key,
//! we can apply different sorting criteria for the same array of draw calls.
//!
//! Finally, stateful draw call and render state manipulation is error-prone,
//! and a bad abstraction. Ideally, submitting a draw call with whatever
//! state we want should not affect any of the other draw calls, even in
//! multi-thread environments.
//!
pub mod state;
pub mod buffer;
pub mod backend;
pub mod frame;
pub mod frontend;

const MAX_VERTEX_ATTRIBUTES: usize = 8;
const MAX_UNIFORMS: usize = 32;

/// Specifies what kind of primitives to render.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Primitive {
    Points,
    Lines,
    LineLoop,
    LineStrip,
    Triangles,
    TriangleStrip,
    TriangleFan,
}