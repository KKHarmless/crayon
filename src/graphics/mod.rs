//! #### Graphics Subsystem
//! Graphics is the most fundamental subsystem of [Lemon3d](http://github.com/kayak233/lemon3d).
//! It was degisned to provide a set of stateless and high-performance
//! graphics APIs based on OpenGL.
//!
//! #### General Thoughts
//! First of all, we follows a data-oriented approach, and uses a task
//! scheduler to perform multithread entities resolving. Its much more
//! convenient to provide mechanism to make video resource preparations
//! and drawcall submits in different threads.
//!
//! The most common solution is by using a double-buffer of commands.
//! This consists of running the renderer backend in a speparate thread,
//! where all draw calls and communication with the OpenGL API are
//! performed. The frontend thread that runs the game logic communicates
//! with the backend renderer via a command double-buffer.
//!
//! And its important to sort video commands (generated by different
//! threads) before submiting them to OpenGL, for the sack of both
//! correctness and performance. For example, to draw transparent objects
//! via blending, we need draw opaque object first, usually from
//! front-to-back, and draw translucents from back-to-front. We can
//! achieve this point by sorting commands before swaping command-buffer.
//!
//! There are some assumptions here to keep codes as simple as possible, this
//! sometimes creates undesired results.
//! 1. All the resource creations and manipulations will be happened before
//! real draw call;
//! 2. All the resource destructions will be finished after real draw call.
//!
//! As a optimation, we use a key associated with every-drawcall to sort.
//! Typically, a key is just a single 32-bit or 64-bit integer encoded
//! certain data like distance, material, shader, etc. of a draw call in
//! individual bits. Depending on where those bits are stored in the key,
//! we can apply different sorting criteria for the same array of draw calls.
//!
//! Finally, stateful draw call and render state manipulation is error-prone,
//! and a bad abstraction. Ideally, submitting a draw call with whatever
//! state we want should not affect any of the other draw calls, even in
//! multi-thread environments.
//!

use super::utility::Handle;

pub mod vertex;
pub mod backend;
// pub mod frontend;

const MAX_VERTEX_ATTRIBUTES: usize = 8;
const MAX_UNIFORMS: usize = 32;

/// Specifies what kind of primitives to render.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Primitive {
    Points,
    Lines,
    LineLoop,
    LineStrip,
    Triangles,
    TriangleStrip,
    TriangleFan,
}

/// Specifies the target to which the buffer object is bound
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Buffer {
    /// Vertex attributes.
    Vertex,
    /// Vertex array indices.
    Index,
}

/// Hint abouts how this memory will be used.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BufferHint {
    /// Full speed GPU access. Optimal for render targets and resourced memory.
    Static,
    /// CPU to GPU data flow with update commands.
    /// Used for dynamic buffer data, typically constant buffers.
    Dynamic,
}

/// Specify whether front- or back-facing polygons can be culled.
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum CullFace {
    Nothing,
    Front,
    Back,
}

/// Define front- and back-facing polygons.
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum FrontFaceOrder {
    Clockwise,
    CounterClockwise,
}

/// A pixel-wise comparison function.
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum Comparison {
    Never,
    Less,
    LessOrEqual,
    Greater,
    GreaterOrEqual,
    Equal,
    NotEqual,
    Always,
}

/// Specifies how incoming RGBA values (source) and the RGBA in framebuffer (destination)
/// are combined.
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum Equation {
    /// Adds source and destination. Source and destination are multiplied
    /// by blending parameters before addition.
    Add,
    /// Subtracts destination from source. Source and destination are
    /// multiplied by blending parameters before subtraction.
    Subtract,
    /// Subtracts source from destination. Source and destination are
    /// multiplied by blending parameters before subtraction.
    ReverseSubtract,
}

/// Blend values.
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum BlendValue {
    SourceColor,
    SourceAlpha,
    DestinationColor,
    DestinationAlpha,
}

/// Blend factors.
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum BlendFactor {
    Zero,
    One,
    Value(BlendValue),
    OneMinusValue(BlendValue),
}
